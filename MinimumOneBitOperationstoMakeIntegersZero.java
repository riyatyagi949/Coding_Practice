/**
 * Problem Statement: Minimum One Bit Operations to Make Integers Zero
 * ------------------------------------------------------------------
 * Given an integer n, find the minimum number of operations to transform it into 0.
 * The allowed operations are:
 * 1. Change the rightmost (0th) bit.
 * 2. Change the i-th bit if the (i-1)-th bit is 1 and bits (i-2) through 0 are 0.
 * * Constraints: 0 <= n <= 10^9
 *//**
     * Optimal Solution: Recursive Relation based on Gray Code
     * --------------------------------------------------------
     * The sequence of numbers generated by these two operations is identical to the 
     * **Gray Code** sequence, which is a binary numeral system where two successive 
     * values differ in only one bit. The operation count to reach '0' from 'n' is 
     * equivalent to finding the position of 'n' in the Gray Code sequence starting from 0.
     * * The problem can be solved by a **recursive/dynamic programming** approach:
     * * Let cost(n) be the minimum operations to transform 'n' to 0.
     * Let msb be the position of the Most Significant Bit of n.
     * Let k = 2^msb be the value of the MSB.
     * Let n' = n XOR k (n with its MSB flipped to 0).
     * * 1. **Target:** Change n (1xxxx...) to k (1000...)
     * - This takes **1** operation (flipping the MSB using Operation 2) IF $n = k$.
     * - The cost to go from $2^{msb}$ (100...0) to 0 is $2^{msb+1} - 1$.
     * * 2. **General Case:** If $n = 1xxxx...$
     * - **Goal 1: Change n (1xxxx...) to k (1000...)**
     * - The cost to go from $n$ to $k$ is $cost(n')$, where $n' = n \oplus k$.
     * - **Goal 2: Change k (1000...) to 0 (0000...)**
     * - The cost to go from $2^{msb}$ to 0 is $\mathbf{2^{msb+1} - 1}$.
     * * - **Relationship:** The sequence of moves to get $2^{msb}$ to $0$ is the **reverse**
     * of the sequence to get $0$ to $2^{msb}$, and the cost to get $n'$ to $0$ is the
     * same as the cost to get $0$ to $n'$.
     * * - **Final Formula:** $cost(n) = (2^{msb+1} - 1) - cost(n \oplus 2^{msb})$
     * - The term $(2^{msb+1} - 1)$ is the cost to go from $2^{msb}$ to $0$.
     * - The recursive call $\text{cost}(n \oplus 2^{msb})$ is the cost to go from $n$ to $2^{msb}$.
     * - The full logic path is: $n \xrightarrow{\text{cost}(n \oplus 2^{msb})} 2^{msb} \xrightarrow{(2^{msb+1} - 1) \text{ ops}} 0$ 
     * * * This specific implementation uses the Gray Code property directly:
     * * $\text{cost}(n) = n \oplus (n >> 1) \oplus (n >> 2) \oplus \dots$
     * * Or, the direct bitwise XOR property of the Gray code position.
     *
     * * The provided recursive code is a concise way to implement this DP relation.
     *//**
 * Time Complexity Analysis:
 * -------------------------
 * O(log N)
 * - The time complexity is determined by the number of recursive calls.
 * - In each call, the value of 'n' is reduced by its Most Significant Bit (MSB), meaning 
 * the number of set bits decreases, or the MSB index decreases.
 * - The recursion depth is equal to the number of bits in 'n', which is $\log_2 n$.
 * - All operations inside the function (bit shifting, XOR, and the `while` loop to find MSB) 
 * are O(1) or O(log N) in total across all calls.
 * - Overall complexity: O(log N).
 *
 * Space Complexity Analysis:
 * --------------------------
 * O(log N)
 * - This space is used by the recursion stack, whose maximum depth is $\log_2 n$ (number of bits).
 */
// Optimal Solution in Java - 

class Solution {
    public int minimumOneBitOperations(int n) {
        if (n == 0)
         return 0;
         
        // most significant bit position
        int msb = 0; 
        while ((1 << (msb + 1)) <= n)
         msb++;
        
        return (1 << (msb + 1)) - 1 - minimumOneBitOperations(n ^ (1 << msb));
    }
}