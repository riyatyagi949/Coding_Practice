/**
 * Problem Statement:
 * Given a keypad (like a phone's T9 keypad) and an array `a[]` of digits, find and list all possible words
 * that can be generated by pressing the numbers in the array sequentially. Digits 0 and 1 do not map to any letters.
 *
 * Keypad Mapping (Standard T9/Phone Keypad):
 * 0: ""
 * 1: ""
 * 2: "abc"
 * 3: "def"
 * 4: "ghi"
 * 5: "jkl"
 * 6: "mno"
 * 7: "pqrs"
 * 8: "tuv"
 * 9: "wxyz"
 *
 * Optimal Approach: Backtracking / Recursion
 * This problem is a classic application of the **Backtracking** (or recursive Depth-First Search) algorithm.
 * We need to explore all combinations of characters where the first character comes from the mapping of the first digit,
 * the second character from the mapping of the second digit, and so on.
 *
 * 1. Mapping: Create a constant array or map to store the string of letters corresponding to each digit (2 through 9).
 * 2. Recursive Function (Backtracking): Define a function, say `solve(digitIndex, currentString, arr, result, mapping)`, which takes:
 * - `digitIndex`: The index of the digit in the input array `arr` we are currently processing.
 * - `currentString`: The word built so far.
 * - `arr`: The input array of digits.
 * - `result`: The list to store final words.
 * - `mapping`: The keypad mapping.
 * 3. Base Case: If `digitIndex` reaches the length of the input array `arr`, it means a complete word has been formed. Add `currentString` to the `result` list and return.
 * 4. Recursive Step:
 * - Get the current digit `digit = arr[digitIndex]`.
 * - Get the corresponding letters string `letters` from the `mapping`.
 * - Iterate through each character `c` in `letters`:
 * - Recursively call `solve(digitIndex + 1, currentString + c, arr, result, mapping)` to build the next part of the word.
 *
 * This process ensures that every combination of letters from the corresponding digits is explored exactly once, leading to all possible words. Digits 0 and 1 are naturally handled by having an empty string mapping for them, which means the loop in the recursive step will simply skip to the next digit.
 *
 * Time Complexity: O(4^n), where 'n' is the length of the input digit array `a[]`. In the worst case (e.g., digits 7 and 9), a digit maps to 4 letters. The total number of words generated is at most $4^n$. Each word takes $O(n)$ time to build/copy, so the total time is closer to $O(n \cdot 4^n)$.
 * Space Complexity: O(n) for the recursion stack depth (equal to the number of digits) and $O(n \cdot 4^n)$ to store the list of all generated words.
 */
// Optimal Solution in Java - 

class Solution {
    public ArrayList<String> possibleWords(int[] arr) {
        ArrayList<String> result = new ArrayList<>();
        if (arr == null || arr.length == 0) return result;
        
        String[] keypad = {
            "",    // 0
            "",    // 1
            "abc", // 2
            "def", // 3
            "ghi", // 4
            "jkl", // 5
            "mno", // 6
            "pqrs",// 7
            "tuv", // 8
            "wxyz" // 9
        };
        
        backtrack(arr, 0, "", result, keypad);
        return result;
    }
    
    private void backtrack(int[] arr, int index, String current, ArrayList<String> result, String[] keypad) {
        if (index == arr.length) {
            if (!current.isEmpty()) 
            result.add(current);
            return;
        }
            if (arr[index] == 0 || arr[index] == 1) {
            backtrack(arr, index + 1, current, result, keypad);
            return;
        }
        
        String letters = keypad[arr[index]];
        for (char c : letters.toCharArray()) {
            backtrack(arr, index + 1, current + c, result, keypad);
        }
    }
}
